
//***************** Manhattan Distance Function****************************
// Calculate Manhattan distance between two points
// each point is two 4-bit unsigned numbers packed into an 8-bit value
// Input parameter:  n1 = (x1,y1) is position of first point
//                   n2 = (x2,y2) is position of second point
// Output parameter:  |x1-x2| plus |y1-y2|
// Error conditions: none
// Test Cases:
//  n1   x1,y1    n2   x2,y2  ManhattanDistance
// 0x00 ( 0, 0), 0x30 ( 3, 0)    3+0=3
// 0x4F ( 4,15), 0x58 ( 5, 8)    1+7=8  
// 0xCE (12,14), 0x1A ( 1,10)   11+4=15
// 0x2D ( 2,13), 0x2D ( 2,13)    0+0=0
// 0xF0 (15, 0), 0x0F ( 0,15)  15+15=30

MY SOLUTION:
uint32_t ManhattanDistance(uint8_t n1, uint8_t n2){
uint32_t distance = 0;
uint8_t x1 = (n1 & 0xF0) >> 4;
uint8_t y1 = (n1 & 0x0F);
uint8_t x2 = (n2 & 0xF0) >> 4;
uint8_t y2 = (n2 & 0x0F);
//variable = (condition)?(if true this):(else this);
distance = (x1>x2)?(x1-x2):(x2-x1);
distance += (y1>y2)?(y1-y2):(y2-y1);
return distance;

//******************Highest**************************
// You are given two numbers a and m
// Your function should find the largest number n such that
// a^n is less than or equal to m
// Input:  a is a 32-bit unsigned value
//         m is a 32-bit unsigned value
// Output: largest possible 32-bit value n
// Error conditions: ignore overflow possibilities
// Test Cases:
// a^n is less than or equal to m
// 2^4 is less than or equal to 16
// 3^5 is less than or equal to 250
// 4^6 is less than or equal to 10000
// 10^1 is less than or equal to 10
// 24^0 is less than or equal to 20

MY SOLUTION:
uint32_t Highest(uint32_t a, uint32_t m){
uint32_t n = 0;
uint32_t exp = 1;

if(a>m){
return 0;
}
else if(a==m){
return 1;
}
while(exp<=m){
exp*=a;
 n++;
}
 
  return n-1;
}
